package client

import (
	"context"
	"fmt"
	"net/http"

	"github.com/pro-deploy/nexus-protocol/sdk/go/types"
)

// AdminClient предоставляет методы для управления конфигурацией системы (только для администраторов)
type AdminClient struct {
	client *Client
}

// NewAdminClient создает клиент для административных операций
func (c *Client) Admin() *AdminClient {
	return &AdminClient{client: c}
}

// GetAIConfig получает текущую конфигурацию AI
func (ac *AdminClient) GetAIConfig(ctx context.Context) (*types.AIConfig, error) {
	resp, err := ac.client.doRequest(ctx, http.MethodGet, PathAPIV1AdminAIConfig, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get AI config: %w", err)
	}
	defer resp.Body.Close()

	var config types.AIConfig
	if err := ac.client.parseResponse(resp, &config); err != nil {
		return nil, err
	}
	return &config, nil
}

// UpdateAIConfig обновляет конфигурацию AI
func (ac *AdminClient) UpdateAIConfig(ctx context.Context, config *types.AIConfig) error {
	resp, err := ac.client.doRequest(ctx, http.MethodPut, PathAPIV1AdminAIConfig, config)
	if err != nil {
		return fmt.Errorf("failed to update AI config: %w", err)
	}
	defer resp.Body.Close()

	if err := ac.client.parseResponse(resp, nil); err != nil {
		return err
	}
	return nil
}

// ListPrompts получает список всех промптов
func (ac *AdminClient) ListPrompts(ctx context.Context, domain string) ([]*types.PromptConfig, error) {
	path := PathAPIV1AdminPrompts
	if domain != "" {
		path += "?domain=" + domain
	}

	var prompts []*types.PromptConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &prompts)
	if err != nil {
		return nil, fmt.Errorf("failed to list prompts: %w", err)
	}
	return prompts, nil
}

// GetPrompt получает промпт по ID
func (ac *AdminClient) GetPrompt(ctx context.Context, id string) (*types.PromptConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminPrompts, id)
	var prompt types.PromptConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &prompt)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt %s: %w", id, err)
	}
	return &prompt, nil
}

// CreatePrompt создает новый промпт
func (ac *AdminClient) CreatePrompt(ctx context.Context, prompt *types.PromptConfig) (*types.PromptConfig, error) {
	var created types.PromptConfig
	err := ac.client.doRequest(ctx, http.MethodPost, PathAPIV1AdminPrompts, prompt, &created)
	if err != nil {
		return nil, fmt.Errorf("failed to create prompt: %w", err)
	}
	return &created, nil
}

// UpdatePrompt обновляет существующий промпт
func (ac *AdminClient) UpdatePrompt(ctx context.Context, id string, prompt *types.PromptConfig) (*types.PromptConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminPrompts, id)
	var updated types.PromptConfig
	err := ac.client.doRequest(ctx, http.MethodPut, path, prompt, &updated)
	if err != nil {
		return nil, fmt.Errorf("failed to update prompt %s: %w", id, err)
	}
	return &updated, nil
}

// DeletePrompt удаляет промпт
func (ac *AdminClient) DeletePrompt(ctx context.Context, id string) error {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminPrompts, id)
	err := ac.client.doRequest(ctx, http.MethodDelete, path, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to delete prompt %s: %w", id, err)
	}
	return nil
}

// ListDomains получает список всех доменов
func (ac *AdminClient) ListDomains(ctx context.Context) ([]*types.DomainConfig, error) {
	var domains []*types.DomainConfig
	err := ac.client.doRequest(ctx, http.MethodGet, PathAPIV1AdminDomains, nil, &domains)
	if err != nil {
		return nil, fmt.Errorf("failed to list domains: %w", err)
	}
	return domains, nil
}

// GetDomain получает домен по ID
func (ac *AdminClient) GetDomain(ctx context.Context, id string) (*types.DomainConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminDomains, id)
	var domain types.DomainConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &domain)
	if err != nil {
		return nil, fmt.Errorf("failed to get domain %s: %w", id, err)
	}
	return &domain, nil
}

// CreateDomain создает новый домен
func (ac *AdminClient) CreateDomain(ctx context.Context, domain *types.DomainConfig) (*types.DomainConfig, error) {
	var created types.DomainConfig
	err := ac.client.doRequest(ctx, http.MethodPost, PathAPIV1AdminDomains, domain, &created)
	if err != nil {
		return nil, fmt.Errorf("failed to create domain: %w", err)
	}
	return &created, nil
}

// UpdateDomain обновляет домен
func (ac *AdminClient) UpdateDomain(ctx context.Context, id string, domain *types.DomainConfig) (*types.DomainConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminDomains, id)
	var updated types.DomainConfig
	err := ac.client.doRequest(ctx, http.MethodPut, path, domain, &updated)
	if err != nil {
		return nil, fmt.Errorf("failed to update domain %s: %w", id, err)
	}
	return &updated, nil
}

// DeleteDomain удаляет домен
func (ac *AdminClient) DeleteDomain(ctx context.Context, id string) error {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminDomains, id)
	err := ac.client.doRequest(ctx, http.MethodDelete, path, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to delete domain %s: %w", id, err)
	}
	return nil
}

// UpdateDomainKeywords обновляет ключевые слова домена
func (ac *AdminClient) UpdateDomainKeywords(ctx context.Context, domainID string, keywords []string) error {
	path := fmt.Sprintf("%s/%s/keywords", PathAPIV1AdminDomains, domainID)
	err := ac.client.doRequest(ctx, http.MethodPut, path, keywords, nil)
	if err != nil {
		return fmt.Errorf("failed to update domain keywords for %s: %w", domainID, err)
	}
	return nil
}

// GetDomainKeywords получает ключевые слова домена
func (ac *AdminClient) GetDomainKeywords(ctx context.Context, domainID string) ([]string, error) {
	path := fmt.Sprintf("%s/%s/keywords", PathAPIV1AdminDomains, domainID)
	var keywords []string
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &keywords)
	if err != nil {
		return nil, fmt.Errorf("failed to get domain keywords for %s: %w", domainID, err)
	}
	return keywords, nil
}

// UpdateDomainCapabilities обновляет возможности домена
func (ac *AdminClient) UpdateDomainCapabilities(ctx context.Context, domainID string, capabilities []types.DomainCapability) error {
	path := fmt.Sprintf("%s/%s/capabilities", PathAPIV1AdminDomains, domainID)
	err := ac.client.doRequest(ctx, http.MethodPut, path, capabilities, nil)
	if err != nil {
		return fmt.Errorf("failed to update domain capabilities for %s: %w", domainID, err)
	}
	return nil
}

// GetDomainCapabilities получает возможности домена
func (ac *AdminClient) GetDomainCapabilities(ctx context.Context, domainID string) ([]types.DomainCapability, error) {
	path := fmt.Sprintf("%s/%s/capabilities", PathAPIV1AdminDomains, domainID)
	var capabilities []types.DomainCapability
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &capabilities)
	if err != nil {
		return nil, fmt.Errorf("failed to get domain capabilities for %s: %w", domainID, err)
	}
	return capabilities, nil
}

// UpdateDomainQualityRules обновляет правила качества домена
func (ac *AdminClient) UpdateDomainQualityRules(ctx context.Context, domainID string, rules []types.QualityRule) error {
	path := fmt.Sprintf("%s/%s/quality-rules", PathAPIV1AdminDomains, domainID)
	err := ac.client.doRequest(ctx, http.MethodPut, path, rules, nil)
	if err != nil {
		return fmt.Errorf("failed to update domain quality rules for %s: %w", domainID, err)
	}
	return nil
}

// GetDomainQualityRules получает правила качества домена
func (ac *AdminClient) GetDomainQualityRules(ctx context.Context, domainID string) ([]types.QualityRule, error) {
	path := fmt.Sprintf("%s/%s/quality-rules", PathAPIV1AdminDomains, domainID)
	var rules []types.QualityRule
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &rules)
	if err != nil {
		return nil, fmt.Errorf("failed to get domain quality rules for %s: %w", domainID, err)
	}
	return rules, nil
}

// UpdateDomainMLModel обновляет ML модель домена
func (ac *AdminClient) UpdateDomainMLModel(ctx context.Context, domainID string, model *types.DomainMLModel) error {
	path := fmt.Sprintf("%s/%s/ml-model", PathAPIV1AdminDomains, domainID)
	err := ac.client.doRequest(ctx, http.MethodPut, path, model, nil)
	if err != nil {
		return fmt.Errorf("failed to update domain ML model for %s: %w", domainID, err)
	}
	return nil
}

// GetDomainMLModel получает ML модель домена
func (ac *AdminClient) GetDomainMLModel(ctx context.Context, domainID string) (*types.DomainMLModel, error) {
	path := fmt.Sprintf("%s/%s/ml-model", PathAPIV1AdminDomains, domainID)
	var model types.DomainMLModel
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &model)
	if err != nil {
		return nil, fmt.Errorf("failed to get domain ML model for %s: %w", domainID, err)
	}
	return &model, nil
}

// InitializeDefaultDomains инициализирует домены по умолчанию
func (ac *AdminClient) InitializeDefaultDomains(ctx context.Context) error {
	err := ac.client.doRequest(ctx, http.MethodPost, PathAPIV1AdminDomains+"/initialize-default", nil, nil)
	if err != nil {
		return fmt.Errorf("failed to initialize default domains: %w", err)
	}
	return nil
}

// ListIntegrations получает список всех интеграций
func (ac *AdminClient) ListIntegrations(ctx context.Context, integrationType string) ([]*types.IntegrationConfig, error) {
	path := PathAPIV1AdminIntegrations
	if integrationType != "" {
		path += "?type=" + integrationType
	}

	var integrations []*types.IntegrationConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &integrations)
	if err != nil {
		return nil, fmt.Errorf("failed to list integrations: %w", err)
	}
	return integrations, nil
}

// GetIntegration получает интеграцию по ID
func (ac *AdminClient) GetIntegration(ctx context.Context, id string) (*types.IntegrationConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminIntegrations, id)
	var integration types.IntegrationConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &integration)
	if err != nil {
		return nil, fmt.Errorf("failed to get integration %s: %w", id, err)
	}
	return &integration, nil
}

// CreateIntegration создает новую интеграцию
func (ac *AdminClient) CreateIntegration(ctx context.Context, integration *types.IntegrationConfig) (*types.IntegrationConfig, error) {
	var created types.IntegrationConfig
	err := ac.client.doRequest(ctx, http.MethodPost, PathAPIV1AdminIntegrations, integration, &created)
	if err != nil {
		return nil, fmt.Errorf("failed to create integration: %w", err)
	}
	return &created, nil
}

// UpdateIntegration обновляет интеграцию
func (ac *AdminClient) UpdateIntegration(ctx context.Context, id string, integration *types.IntegrationConfig) (*types.IntegrationConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminIntegrations, id)
	var updated types.IntegrationConfig
	err := ac.client.doRequest(ctx, http.MethodPut, path, integration, &updated)
	if err != nil {
		return nil, fmt.Errorf("failed to update integration %s: %w", id, err)
	}
	return &updated, nil
}

// DeleteIntegration удаляет интеграцию
func (ac *AdminClient) DeleteIntegration(ctx context.Context, id string) error {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminIntegrations, id)
	err := ac.client.doRequest(ctx, http.MethodDelete, path, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to delete integration %s: %w", id, err)
	}
	return nil
}

// ListFrontendConfigs получает список всех конфигураций frontend
func (ac *AdminClient) ListFrontendConfigs(ctx context.Context) ([]*types.FrontendConfig, error) {
	var configs []*types.FrontendConfig
	err := ac.client.doRequest(ctx, http.MethodGet, PathAPIV1AdminFrontendConfigs, nil, &configs)
	if err != nil {
		return nil, fmt.Errorf("failed to list frontend configs: %w", err)
	}
	return configs, nil
}

// GetFrontendConfig получает конфигурацию frontend по ID
func (ac *AdminClient) GetFrontendConfig(ctx context.Context, id string) (*types.FrontendConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminFrontendConfigs, id)
	var config types.FrontendConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &config)
	if err != nil {
		return nil, fmt.Errorf("failed to get frontend config %s: %w", id, err)
	}
	return &config, nil
}

// GetActiveFrontendConfig получает активную конфигурацию frontend
func (ac *AdminClient) GetActiveFrontendConfig(ctx context.Context) (*types.FrontendConfig, error) {
	path := PathAPIV1AdminFrontendConfigs + "/active"
	var config types.FrontendConfig
	err := ac.client.doRequest(ctx, http.MethodGet, path, nil, &config)
	if err != nil {
		return nil, fmt.Errorf("failed to get active frontend config: %w", err)
	}
	return &config, nil
}

// CreateFrontendConfig создает новую конфигурацию frontend
func (ac *AdminClient) CreateFrontendConfig(ctx context.Context, config *types.FrontendConfig) (*types.FrontendConfig, error) {
	var created types.FrontendConfig
	err := ac.client.doRequest(ctx, http.MethodPost, PathAPIV1AdminFrontendConfigs, config, &created)
	if err != nil {
		return nil, fmt.Errorf("failed to create frontend config: %w", err)
	}
	return &created, nil
}

// UpdateFrontendConfig обновляет конфигурацию frontend
func (ac *AdminClient) UpdateFrontendConfig(ctx context.Context, id string, config *types.FrontendConfig) (*types.FrontendConfig, error) {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminFrontendConfigs, id)
	var updated types.FrontendConfig
	err := ac.client.doRequest(ctx, http.MethodPut, path, config, &updated)
	if err != nil {
		return nil, fmt.Errorf("failed to update frontend config %s: %w", id, err)
	}
	return &updated, nil
}

// SetActiveFrontendConfig устанавливает активную конфигурацию frontend
func (ac *AdminClient) SetActiveFrontendConfig(ctx context.Context, id string) error {
	path := fmt.Sprintf("%s/%s/active", PathAPIV1AdminFrontendConfigs, id)
	err := ac.client.doRequest(ctx, http.MethodPut, path, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to set active frontend config %s: %w", id, err)
	}
	return nil
}

// DeleteFrontendConfig удаляет конфигурацию frontend
func (ac *AdminClient) DeleteFrontendConfig(ctx context.Context, id string) error {
	path := fmt.Sprintf("%s/%s", PathAPIV1AdminFrontendConfigs, id)
	err := ac.client.doRequest(ctx, http.MethodDelete, path, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to delete frontend config %s: %w", id, err)
	}
	return nil
}

// GetVersion получает информацию о версии системы
func (ac *AdminClient) GetVersion(ctx context.Context) (map[string]string, error) {
	var version map[string]string
	err := ac.client.doRequest(ctx, http.MethodGet, PathAPIV1AdminVersion, nil, &version)
	if err != nil {
		return nil, fmt.Errorf("failed to get version info: %w", err)
	}
	return version, nil
}
